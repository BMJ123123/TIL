# 📅 BFS

BFS : 그래프를 방문 또는 탐색하는 방법론

갈림길에 연결되어 있는 모든 길을 한번씩 탐색한 뒤 다시 연결되어 있는 모든 길을 넓게 탐색한다.

<img width="700" alt="image" src='https://i.imgur.com/LJZrqYZ.gif'/>

DFS의 경우 하나의 길로 들어섰을 때 막다른 길까지 탐색한다면, BFS의 경우 모든 경로를 동시에 진행하기 때문에 탐색이 정형화 돼 있다는 점이다.

DFS는 아직 학습이 충분하지 않아 나중에 다루도록 한다.


나의 경우 백준 1926번(그림) 문제로 느낌을 익혔다. 이 문제의 해설을 가지고 내가 BFS를 어떻게 이해했는지 알아보도록 하자.

소스 코드는 아래 블로그를 참고했다.

https://iingang.github.io/posts/BOJ-1926/


문제

    어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 
    
    가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.


예제 입력 1

    1 1 0 1 1
    0 1 1 0 0
    0 0 0 0 0
    1 0 1 1 1
    0 0 1 1 1
    0 0 1 1 1


나는 처음에는 해설이 이해 되지 않았다. 이러한 알고리즘으로 진행하면, 중간에 끊겨 버리는 경우가 없을지 확신할 수 없었기 때문이다.

그러나 그렇지 않았다.

아래는 예제 입력을 45도 돌린 그림이다.

<img width="700" alt="image" src='https://i.ibb.co/bH0Q73k/Screenshot-20231218-193120-Samsung-Notes.jpg'/>

<img width="700" alt="image" src='https://i.ibb.co/6WyD7S9/Screenshot-20231218-193718-Samsung-Notes.jpg'/>

첫번째 사진의 파란색은 인덱스 값이고 두번째 사진의 주황색은 각각 노드의 간선을 표시한 것이다.

각각의 노드(좌표)들은 간선으로 연결 돼 있다. 1과 1이 간선으로 연결 돼 있다면, BFS를 통해 정상적으로 카운트 될 수 있다는 것을 시각적으로 이해 됐고, BFS는 점층적으로 진행되기 때문에 꼬일 일도 없던 것이다.

이상 BFS에 대해서 학습했다.
다음엔 DFS를 공부하여 트리에 기본적인 학습을 진행하도록 한다.