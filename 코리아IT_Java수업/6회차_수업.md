# 📅 5회차 수업

Java 기초

- 에외 처리
- 클래스
- 생성자 활용
- this 레퍼런스
- 객체 배열


예외 처리 (교제 14단원)


    예외
    - 자바에서 오동작이나 결과에 악영향을 미칠 수 있는 실행 중 발생한 오류

    vs.
    컴파일 오류
    - 코드를 잘 못 쓴 경우

    예외의 예시
    - 7/0 : 정수를 0으로 나눈 경우
    - int a[] = new int[5]; : a[5], a[-1] 배열의 크기를 벗어난 인덱스 번호를 사용한 경우
    - 정수를 입력받아야 하는데(SC.nextInt()) 문자열을 입력한 경우


    자주 발생하는 예외 종류
    -정수를 0으로 나눌 때 발생

    - 비어있는 레퍼런스를 참조할 때 발생

    - 변환할 수 없는 타입으로 캐스팅을 진행할 때 발생

    - 메모리가 부족한 경우에 발생

    - 배열의 범위를 벗어나 접근 할 때 발생

    - 프로그램으로 잘못된 인자를 전달할 때 발생

    - 포멧을 이용한 출력에서 포멧을 지키지 않은 경우

    - 입출력 동작 실패 또는 인터럽트 시 발생

    - Scanner 클래스에서 사용한 함수의 자료형과 입력한 자료형이 일치하지 않는 경우

    try-catch-finally 문
    try{
        예외가 발생 할 수 있는 실행문
    } catch(예외의 종류){
        예외 처리 문
    }
    finally { // 생략 가능 (선택 사항)
        예외 발생 여부와 상관없이 무조건 실행되는 문
    }

    try에서 예외가 발생한 경우
    try -> catch -> finally

    예외가 발생하지 않은 경우
    try -> finally


클래스 (교재 7단원)


    객체 (object)
    -> 클래스라는 틀로 찍어낸다
    Scanner sc = new Scanner(System.in);
    sc.nextInt(); -> 

    객체 지향 언어의 특성
    - 캡슐화 (Encapsulation)
    객체를 캡슐로 감싸서 내부 정보를 보호
    일부에 대해서는 객체의 메소드(레퍼런스타입의 함수)나 필드(레퍼런스 타입의 변수)를 공개가 되어 있음 -> 접근 지정자

    - 상속 (Inheritance)
    부모 클래스(슈퍼, 상위)와 자식 클래스(서브, 하위) 간에 물려받는 필드
    자식 클래스는 부모 클래스를 확장해서 자신만의 메소드, 필드를 가짐

    ex) 동물 클래스 -> 이름, 나이, 먹다(), 자다(), 울부짖다()
        사람 클래스 -> 동물 클래스의 요소 + 취미, 직업, 일하다()
        -> 사람 클래스에서 동물 클래스의 요소를 그대로 가져와서 확장(extends)이 되어
        코드의 중복을 줄일 수 있음

    - 다형성 (Polymorphism)
    같은 이름의 메소드/ 필드더라도 클래스/객체 마다 다르게 동작하도록 구현
    오버라이딩 (overriding) -> 상속 관계에서 자식 클래스가 부모클래스로부터 상속받은 메소드/필드를 자신에 맞추어 바꾼것
    오버로딩 -> 한 클래스 내부에서 동일한 이름의 메소드를 가지는데 파라미터에 따라서 다르게 구현된 것

    ex) 동물 클래스를 상속받는 개 클래스, 고양이 클래스, 호랑이 클래스
        각 동물별 클래스는 울부짖다() 메소드가 다르게 구현되어야 함 -> 오버라이딩
        개 클래스 내부에서 울부짖다(부위) -> 울부짖다(머리), 울부짖다(등) -> 오버로딩  // 오버로딩 == 한 클래스 내에서

    public class Circle {
    -> pubilc: 메인 클래스 (접근 지정자) - 캡슐화
    -> class Circle : circle 이라는 이름의 클래스 선언
    -> 클래스 내부에 멤버(필드, 메소드)
    -> 클래스 밖에는 펠드, 메소드를 선언 할 수 없음 -> 캡슐화

        public int radius; // 필드를 만든다는데 뭔뜻임 <- 전역변수인가
        public String name;
        -> 클래스 내부의 저장되어 있는 멤버 변수를 필드

        public Circle() {	
        }
        *** 생성자 ***
        -> 클래스의 이름과 메소드의 이름이 동일한 메소드 = 생성자
        -> 생성자는 객체가 생성될 때 자동으로 제일 처음 호출되는 메소드 // 객체가 뭔데
        -> 생성자는 내 멤버 변수를 초기화 시키는 용도로도 사용

        public double getArea() {
            return 3.14 * radius * radius;
        }
        -> 사용자 지정 메소드
        public static void main(String[] args) {	
        }
        -> 클래스 내부에 지정 되어 있는 멤버 메소드
    }

    public static void main(String[] args) {
        Circle pizza;
        -> Circle이라는 클래스 틀을 가지고 pizza라는 객체를 선언
        -> 선언만 하고 생성하지 않으면 객체에는 null(비었다, 없다)이 들어감

        pizza = new Circle();
        -> Circle이라는 클래스의 객체를 생성
        -> 생성자를 호출하게 됨 + Circle 크기 만큼의 메모리를 할당

        pizza.radius = 10;
        pizza.name = "치즈피자";
        -> Circle 클래스인 pizza 객체의 멤버 변수 radius와 name에 저장

        double area = pizza.getArea();
        -> Circle 클래스인 pizza 개체의 멤버 메소드 getArea()에 접근
        System.out.println(area);
    }
      

생성자 활용


    생성자 = 객체를 처음 생성할 때 호출되는 함수
    - 필드 초기화


    생성자의 특징
    - 생성자의 이름의 클래스의 이름과 동일
    - 생성자는 여러개 쓸 수 있음 (생성자 오버로딩)
    (동일 클래스 내부에서 매개변수에 따라서 다른 역할을 하는 매소드)
    - 생성자는 new 키워드가 있을 때 딱 1번 호출 됨
    - 생성자는 return 하지 않음 
        (return 값이 없는 것이 아니라 return 안함)

    기본 생성자 (default constructor)
    = 매개변수가 비어있는 생성자

    - 기본 생성자는 개발자가 코드를 작성하지 않더라도 빈 코드로 자동 생성이 됨

    class Pizza {
        int radius;
        String name;
        
        public Pizza() {
            radius = 1;
            name = "";
        }
        public Pizza(int r, String n) {
            radius =  r;
            name = n;
        }
	

*** this 레퍼런스 ***


    this = 이것 = 나 자신에 대한 레퍼런스 (참조)
    this의 용도는 내 레퍼런스에 대한 변수임을 명시 해줌

    ex)
    public Pizza (int radius) { radius = radius; }
    -> Warnig <= 애매한 코드
    -> this를 붙여서 앞의 radius는 클래스의 멤버 변수, 뒤의 radius는 생성자의 매개변수

    this() = 나의 또 다른 생성자
    생성자에서 다른 생성자를 호출할 때 this()를 사용
    -> 코드의 중복을 없애기 위해서 사용

    - this()는 반드시 생성자의 가장 첫 줄에 써야한다
    - this는 일반 메소드에서는 사용X, 반드시 생성자 -> 생성자 호출할 때만


객체 배열


    객체 = 레퍼런스
    배열 = 레퍼런스

    일반 자료형 배열 (기본 자료형 + 레퍼런스)
    int intArray[] = new int[5];

    객체 배열 (레퍼런스 + 레퍼런스)
    Circle cArray[] = new Circle[5];
    -> 배열만 선언/생성 = 클래스에 대한 것은 생성이 안되었음

    cArray[][][][][] <- 배열의 각 칸에 대해서 Circle을 생성해야 함
    for(int i=0; i<cArray.length; i++){
        cAraay[i] = new Circle(); // 클레스에서의 생성 방법
    }