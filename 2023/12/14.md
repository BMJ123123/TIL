# 📅 2023/12/14

코딩테스트시에 디버깅이 불가능한 경우가 많다. 따라서 출력 함수와 눈으로만 하여 로직의 오류를 찾는 연습을 시도한다. 

코딩테스트의 경우 사소한 로직 오류도 실패로 이어지기에 기반을 다지도록 한다.

백준

    골드4: 수 묶기
    골드4: 오큰수

--------------------------
오류 및 실수

수 묶기

    반복문의 증가식 세우는 걸 햇갈림 (구상 당시 i+=2 로 했으나 까먹고 i++로 기입함)
    -> 필기한 내용을 주기적으로 보면서 하면 좋을 듯

오큰수

    while문의 종료조건을 까먹어서 무한 루프 발생
    -> break;를 추가하여 해결


발전

    문제의 알고리즘을 구상 할 때 느낌으로 풀려하지 않음 -> 왜 성립하는지에 확신을 입증하고 풀이 제작
    코드 로직을 한글로 미리 작성해 보고 코딩 시작

-----------------------
수 묶기 로직 구상

    /*
    < 0 면 V1에, 아니면 V2에:
    (가능한 이유) {
    V1이 홀수 개일 경우 -> a*b = 양수 -> 마지막 값 -> 마지막 값은 하나 이기 때문에 더해지는데, 0이니 상관 X
    v1이 짝수 개일 경우 -> a*b = 양수 -> 가장 큰 -값은 0이랑 곱해버려서 제거
    }
    기본 세팅: 음수+0을 포함하는 백터 하나, 양수 백터 하나, sum = 0


    로직 {
        음수 백터 의 경우 {
            오름 차순으로 정렬
            for(int i=0; i<v1.size()-1; i+=2){ // 증가식을 까먹음
                //짝수의 경우
                [0]*[1] + [2]*[3] ....
                -> v1.size() = 4, i= 0, 2, 4(여기서 탈락)
                //홀수의 경우
                [0]*[1] ...
                -> v.size() = 3, i = 0, 2(여기서 탈락)
            }
            홀수개 백터의 경우 마지막 값 안 더해졌으니 여기서 if(v.size()%2!=0)일 경우 마지막 값 더하기
        }

        양수 백터의 경우 {
            내림 차순으로 정렬
            for(int i=0; i<v2.size()-1; i++) {
                v2[i]가 1, 혹은 v2[i+1]가 1일 경우
                    sum += v2[i] + v2[i+1];
                아닐 경우
                    sum += v2[i] * v2[i+1]
            }
            홀수개 백터의 경우 마지막 값 안 더해졌으니 여기서 if(v.size()%2!=0)일 경우 마지막 값 더하기
        }
    }
    */


오큰수 로직 구상

    /*
    반복: 백터의 끝번호에서 처음으로 <- {
        스텍이 안 비어있으면 반복:
        비굣값(v[i]) 랑 스텍의 탑과 비교했을 때:
            스택의 탑의 값이 더 크면 -> { answer에 top값 넣고 스텍에 v[i]넣기 } // break 까먹음 -> 반복문을 사용하는데 조건 제어 생각 못함
            스택의 탑의 값이 더 작다면 -> {pop 하기}



        if (스택이 비어있으면):
            스텍에 v[i] 넣고, answer에 -1 집어 넣기
    }
    */