# 📅 2023/12/11

코딩테스트시에 디버깅이 불가능한 경우가 많다. 따라서 출력 함수와 눈으로만 하여 로직의 오류를 찾는 연습을 시도한다. 

코딩테스트의 경우 사소한 로직 오류도 실패로 이어지기에 기반을 다지도록 한다.

프로그래머스

    level 1: N개의 최소공배수

백준

    골드5: AC


오류 및 실수

N개의 최소공배수

    for(int i=2; i<=100; i++) {
        {{ 특정 조건이 성립할 때}}
        -> i를 2로 초기화 하여 재반복
    }

    처음에는 위의 로직으로 구상했다. 그러나 오류가 발생할 수 밖에 없었다.
    if(조건) i = 2; 으로 한다면 다음 회차 반복시 i가 1 증가하게 된다. 따라서 i는 3으로 초기화 되버린다.
    나는 i가 언제 증가하는지에 대해서 간과하고 있었던 것이다. 당연하지만 어떤 사건이 정확히 언제(몇번째 코드에서) 실행되는지 숙지해야 했다.

AC

    반복시 초기화 하는 걸로 구상했으나 초기화 하는 것을 잊었다.
    데이터를 카피하고 함수가 끝나기 전 다시 덮어씌우는 걸로 구상했으나 잊었다.
    반복시 특정 변수를 매번 true로 재초기화 해야 하는 걸 잊었다.
    -> 로직 및 할 일들을 한글로 옮겨서 먼저 해보면 실수를 줄일 수 있다고 생각한다.

    반복 범위를 잘못 지정 했다.
    내가 종료조건이 정확히 언제인지 몰랐기 때문에(느낌으로만 알고 있었기 때문에) 반복횟수가 1회 부족하다는 것을 몰랐다.
    -> 코드에 대한 이해가 부족하다고 판단된다. 당연한 말이지만 본인이 작성한 코드는 정확히 알고있어야 한다는 걸 다시 느꼈다.

    본인이 선언한 변수명도 햇갈려 한다. 선언 방식을 조직화 시켜야 겠다.

    만약 배열의 사이즈가 종료조건에 포함될 때, 배열에 있는 값을 제거하는 로직을 구성할 경우 조건 제어에 매우 신경써야 했다.


***

외울 것 (평소에 자주 사용하나 반복적으로 까먹어 적어놓고 외우도록 한다.)

    - sort 함수
        string: sort(str.begin(), str.end()) { 오름차순의 경우: sort(str.begin(), str.end(), greater<int>()) }
        vector: 동일
        array: sort(arr, arr + 10)


    - find 함수
        char ch = 'a';
        size_t found = str.find(ch);
        
        while (found != string::npos) {
            found = str.find(ch, found + 1);
        }


    - 자료형 변환
        string to int: i = stoi(str)
        string to long: 동일
        string to float: 동일
        string to double: 동일
        등등

        int to string:    str = to_string(num)
        double to string: 동일
        flaot to string:  동일
        등등